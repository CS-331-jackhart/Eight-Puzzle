# Assignment Description
In this assignment you will implement and compare different heuristics of A* search for 8-puzzle. The problem is to take any initial configuration of the puzzle to the goal configuration with a sequence of moves in the smallest number of steps. Fix the goal configuration  as follows.
```
1 2 3
4 5 6
7 8
```

Note that the breadth first search can be viewed as A* search where the heuristic is zero. Hence we will comparing A* search with the following heuristic functions.

BF: Always returns 0 (breadth first search) 
MT: The number of misplaced tiles.
CB: The city-block distance or Manhattan distance.
NA: Your own non-admissible heuristic which is designed to reduce the amount of search.

To study how the amount of search varies with the problem difficulty, we will supply a program  _shuffle(Goal, m) which generates random solvable problems by  applying a random sequence of m moves to the goal state.
```
For m= 10, 20, 30, 40 do  
  For n=10 random problems p generated by _Shuffle(Goal,m) 
 For each algorithm/heuristic function A, 
          Solve p using A  
    Record the length of the solution found, 
               the number of nodes searched, 
                  and the total CPU time spent 
```

You might find that your algorithm is taking too long for some inputs and heuristics. Bound the time and/or the number of nodes searched to a maximum, and count how many problems are solved within that bound. Set the maximums based on your machine limitations and the time you have.

Submit a report with the following plots. Each plot should show one aspect of search as a function of m for the different methods (and heuristics). Indicate the search bounds you have used.

1. Percentage of problems solved   
2. Number of search nodes generated
3. Average CPU time per problem 
4. The average solution length 

Write a brief discussion (1/2 page) answering the following questions. 

1. How did the two algorithms and the three heuristics compare in terms of the number of nodes searched, the solution length, and the CPU time?

 2. Is there a clear preference ordering among the heuristics? Is there a tradeoff between solution length and the number of nodes searched or between CPU time and the number of nodes searched?

3. How did you come up with your heuristic evaluation function?

4. Is there anything you are surprised by or learn from the experiment?

Note that it is very important for this assignment to write efficient code. Please start early.

Report.pdf which includes the following:

1. The results of testing each of your heuristics on 5 random problems.

To test if your A* search is working you can execute the test.py file by calling python test.py in the terminal.

This will run 5 test problems for each of your heuristics and evaluate your solutions.

The test program outputs the board, the solution found by your program, whether the solution is correct or not, and whether the solution is optimal or not.

2. The 4 plots described above
3. The discussion answering the above questions.

Please follow the structure of the scaffolding code and the names of the functions given there to develop your code. If you use a different programming language your report should still follow the format given above including the test problems and their solutions. 
